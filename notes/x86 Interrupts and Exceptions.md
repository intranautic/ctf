High level overview and terminology of interrupts/exceptions, for hardware details see [[x86 APIC]] for more.

Interrupts and exceptions are events which indicate a condition exists somewhere in the system, the processor, or the currently executing program or task that requires the attention of the processor.

When an interrupt or recieved or an exception occurs, the current procedure is suspended and a handler is executed. The processor can recieve from either hardware or software generated interrupts. 

An example of a hardware generated interrupt is a keyboard event, in which the processor will asynchronously handle the interrupt. An example of a software interrupt being generated is the invocation of the `int` instruction on x86.

Exceptions typically indicates an error condition, whereas interrupts indicate events from either software or hardware. One such example is a keyboard device which generates an interrupt when a key is pressed to be handled by the kernel.

Precision describes the state of the program which has generated an error condition. A precise exception reports on a predictable instruction boundary, whereas imprecise exceptions are not guaranteed to report on a predictible instruction boundary. The term boundary simply refers to the point where one instructruction ends and the next begins.

Exceptions are imprecise when it does not occur exactly at the point of the faulting instructions. Imprecise events can be considered asynchronous, as the source of the interrupt isnt necessarily related to the interrupted instruction.

Most exceptions report the boundary before the instruction causing the error condition, in which case all instructions previous to the faulting instruction are allowed to complete and the program state is not affected by the partial execution of the instruction. Some exceptions report the boundary after the instruction generating the exception, in which case all instructions prior to and including the faulting exception were allowed to execute. This means that the faulting instruction may have modified program state.

There are three types of exceptions, varying in precision and how the information they convey about the state of the error condition and program.

Faults are precise exceptions which report on the boundary before the instruction causing the error condition. Generally faults are caused by error conditions involving the actual instruction, such as division by zero. All state caused by the faulting instruction is discarded, and the saved IP points to the faulting instruction (ie, reports on boundary before).

Traps are precise exceptions which reports on the boundary after the instruction causing the error condition. A trap is generated when the trapped instruction is allowed to complete and modify program state. The saved IP will point to the instruction after the instruction generating the trap. An example of a trap is a breakpoint, in which the instruction generates an interrupt and is allowed to complete.

Aborts are imprecise exceptions, as they are imprecise they do not allow reliable program resumtion and are unrecoverable. Because faults and traps are precise, they are recoverable.

A segmentation fault is a fault because it is precise, but is handled as an abort by the kernel due to it being known as a general protection fault (GFP). This type of fault is generated as a result of an access violation, or any synchronous error condition which should not be recoverable. This is enforced by the kernel, rather than the hardware so while segmentation faults are faults, they are treated as aborts by the operating system.

Synchronous interrupts which are generated via software are known as software interrupts. You can explicitly invoke software interrupts via the `int n` instruction, and return from the interrupt via the `iret` instruction. As interrupts are asynchronous with regards to process execution, a context switch must occur in order to preserve context of the currently running process before handling the interrupt.

The `int` instruction will invoke a specific interrupt from the Interrupt Descriptor Table, a table consisting of 256 vectors/entries, the first 32 of which are defined by the processor itself.

Interrupt masking can be done by clearing the EFLAGS.IF bit, which either disables or defers the execution of an interrupt. This is particularly useful for handling nested interrupts which are not reentrant, or during execution of a critical section in which atomicity is a requirement.

Masking external interrupts generated by peripherals will defer execution, once the IF bit is set again the core will then handle the interrupt.